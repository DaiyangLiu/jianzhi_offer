### 数组中的重复数字解题思路：

数组长度为n，其中的所有数字都在0~n-1的范围内。即如果数组中的数字完全不重复，则刚好保证数组下标等于当前下标中存放的数字。如果数组中存放的有重复数字，则必定存在某个下标不等于当前下标中存放的数字的情况。

### bool duplicate(int numbers[], int length, int* duplication)函数编写思路：

1.首先需要对length=0的特殊情况进行判断处理。

2.遍历数组中的每一个元素，利用 **下标=数组下标中的元素** 条件，进行元素置换操作，直到**下标=数组下标中的元素**情况满足为止。

3.元素置换操作对于每一个元素来说，最多只能置换length-1次，超出该次数无意义且可能导致无限循环，故需要对置换次数进行记录，在置换次数=length-1时终止置换操作。

4.在置换操作过程中，可能存在的情况有：



| 情况                                                         | 处理方式                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| a.顺利地满足下标=数组下标中的元素情况                        | 对下一下标的元素进行置换操作                                 |
| b.如果不相等，则进入置换循环，置换过程中发现当前下标中的元素（m）与下标为m的数组中的元素相等（都为m） | 出现重复情况，赋值duplication，返回true                      |
| ~~c.置换次数=length-1，当前下标中的数字已经进行了length-1次置换操作，可能其他元素都已经满足了下标=数组下标中的元素，但当前下标还没有进行检验~~ | ~~对当前下标是否等于数组下标存放的元素，若等于，则对下一个元素进行置换操作，若不等于，则表示肯定出现了重复情况，当前下标存放的数值即为重复的数值~~ |

### 测试用例：

1. 
2. 1 2 3 2
3. 2 1 3 2
4. 2 1 2 3
5. 2 2 1 1
6. 1 2 2 3 3 4



### 语法注意事项：

本题中，函数的最后一个传入参数，为地址。

故在函数内部对地址的使用 *duplication = numbers[i]；的赋值方式。为duplication指向的地址空间进行填充。

而非duplication = &numbers[i]（意为将指针duplication指向numbers[i]）,因numbers作为函数参数，会随着函数调用的结束被释放。



### 观书上指导代码有感：

1.我上面写的c情况其实是冗余的，根本不需要对置换次数进行记录，因为最迟在第length次置换的时候，就会出现numbers[i] == numbers[numbers[i]] 成立的情况。

2.指导代码还对numbers进行了判断，判断其是否为空指针。

3.还对length进行了是否小于等于0的判断，我只对是否等于零进行了判断。

4.还对数组中每个元素是否在0到n-1之间进行了判断。



